/*

 It connects to an MQTT server then:
  - on 0 switches off relay
  - on 1 switches on relay
  - on 2 switches the state of the relay

  - sends 0 on off relay
  - sends 1 on on relay

 It will reconnect to the server if the connection is lost using a blocking
 reconnect function. See the 'mqtt_reconnect_nonblocking' example for how to
 achieve the same result without blocking the main loop.

 The current state is stored in EEPROM and restored on bootup

 //su questo file ci deve stare solo la connessione

*/
#include <caldaia.h>
#include <config.h>
#include <topic.h>
#include <Pins_Arduino.h>
#include <nodeRelay.h>
//#include <string>
#include <ESP8266WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <OneWire.h>
#include <DallasTemperature.h>
//OTA
//#include <ESP8266mDNS.h>
//#include <WiFiUdp.h>
//#include <ArduinoOTA.h>
//Necesary to make Arduino Software autodetect OTA device
//WiFiServer TelnetServer(8266);


//ONE WIRE stuff
const int ONE_WIRE_BUS = D1;
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature DS18B20(&oneWire);
//WIFI Stuff

WiFiClient espClient;
//MQTT stuff
PubSubClient client(espClient);
static const uint8_t D11   = 9;
static const uint8_t D12  = 10;
const int caldaiaPin= D11;  //pin collegato all'ex termostato
const int acquaPin= D12;    //pin collegato al micro dell'acqua sanitaria
const int resetPin= D3;     //pin pulsante reset blocco
const int alarmPin=D4;      //pin luce blocco caldaia
nodeRelay riscaldamento(caldaiaPin); //usato x normale riscaldamento
nodeRelay acquacalda(acquaPin); //usato per preriscaldo acqua calda
nodeRelay allarmeCaldaia(resetPin); //usato per resettare l allarme caldaia
//gestione interrupt se luce alarm attivo
volatile byte interruptCounter = 0;
int numberOfInterrupts = 0;
char temperatureString[6];
void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  //se arriva il topic relay passo il primo carattere alla sub
  //che sara' 0 o 1 attivare o non attivare caldaia
  if (strcmp(topic, riscaldaTopic) == 0) {
    riscaldamento.relay((char)payload[0]);
  }
  //se arriva il topic acquacalda faccio bypassare il micro del flussostato
  //che sara' 0 o 1 attivare o non attivare caldaia
  if (strcmp(topic, acquaTopic) == 0) {
    acquacalda.relay((char)payload[0]);
  }
  //TOPIC Reset Manuale Caldaia se allarme
  if (strcmp(topic, resetTopic) == 0) {
    if((char)payload[0] == '1'){
      allarmeCaldaia.relay('1');
      smartDelay(2000);
      allarmeCaldaia.relay('0');
    }
  }

}
float getTemperature() {
  float temp;
  do {
    DS18B20.requestTemperatures();
    temp = DS18B20.getTempCByIndex(0);
    smartDelay(100);
  } while (temp == 85.0 || temp == (-127.0));
  return temp;
}
/*void myOTAUpdate(){
  Serial.print("Configuring OTA device...");
  TelnetServer.begin();   //Necesary to make Arduino Software autodetect OTA device
  ArduinoOTA.onStart([]() {Serial.println("OTA starting...");});
  ArduinoOTA.onEnd([]() {Serial.println("OTA update finished!");Serial.println("Rebooting...");});
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {Serial.printf("OTA in progress: %u%%\r\n", (progress / (total / 100)));});
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR) Serial.println("End Failed");
  });
  ArduinoOTA.begin();
Serial.println("OK");
}*/
void setup_wifi() {

  delay(10);
  // We start by connecting to a WiFi network
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    //extButton();
    //for(int i = 0; i<500; i++){
    //  extButton();
      delay(500);
    //}
    Serial.print(".");
  }
  digitalWrite(13, LOW);
  delay(500);
  digitalWrite(13, HIGH);
  delay(500);
  digitalWrite(13, LOW);
  delay(500);
  digitalWrite(13, HIGH);
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}
/*
void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  //se arriva il topic relay passo il primo carattere alla sub
  //che sara' 0 o 1 attivare o non attivare caldaia
  if (strcmp(topic, riscaldaTopic) == 0) {
    riscaldamento.relay((char)payload[0]);
  }
  //se arriva il topic acquacalda faccio bypassare il micro del flussostato
  //che sara' 0 o 1 attivare o non attivare caldaia
  if (strcmp(topic, acquaTopic) == 0) {
    acquacalda.relay((char)payload[0]);
  }
  //TOPIC Reset Manuale Caldaia se allarme
  if (strcmp(topic, resetTopic) == 0) {
    if((char)payload[0] == '1'){
      allarmeCaldaia.relay('1');
      smartDelay(2000);
      allarmeCaldaia.relay('0');
    }
  }

}
*/
void reconnect() {
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    // Attempt to connect
    if (client.connect("NodeCaldaia",mqttUser,mqttPass)) {
      Serial.println("connected");
      // Once connected, publish an announcement...
      client.publish(logTopic, "NodeMCU Caldaia connesso");
      // ... and resubscribe
      client.subscribe(riscaldaTopic);
      client.subscribe(acquaTopic);
      client.subscribe(alarmTopic);
      //client.subscribe(resetTopic);
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      // Wait 5 seconds before retrying
      //for(int i = 0; i<5000; i++){
      //  extButton();
        smartDelay(2000);
      //}
    }
  }
}
void setup() {
  pinMode(13, OUTPUT);
  digitalWrite(13, LOW);          // Blink to indicate setup
  delay(500);
  digitalWrite(13, HIGH);
  delay(500);
  Serial.begin(115200);
  setup_wifi();                   // Connect to wifi
  //myOTAUpdate();
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(callback);
  DS18B20.begin();
  //se il piedino di allarme scende a zero (spia accesa)
  //resetta la caldaia
  //attachInterrupt(digitalPinToInterrupt(alarmPin), alarmInterrupt, FALLING);
  //attachInterrupt(digitalPinToInterrupt(alarmPin), alarmInterrupt, FALLING);
}
void alarmInterrupt() {
  interruptCounter++;
  if (interruptCounter < 5) {
    client.publish(logTopic, "Allarme Blocco ,resetto..");
    allarmeCaldaia.relay('1');
    smartDelay(1000);
    allarmeCaldaia.relay('0');
    client.publish(logTopic, "Allarme Blocco ,resettato!");
  }
  StaticJsonBuffer<300> JSONbuffer;
  JsonObject& JSONencoder = JSONbuffer.createObject();
  JSONencoder["Alarm"] = interruptCounter;
  char JSONmessageBuffer[50];
  JSONencoder.printTo(JSONmessageBuffer, sizeof(JSONmessageBuffer));
  Serial.println(JSONmessageBuffer);

  if (client.publish(alarmTopic, JSONmessageBuffer) == true) {
      Serial.println("Success sending message");
  } else {
      Serial.println("Error sending message");
  }
  client.publish(logTopic, "Allarme Blocco ,resettato!");
}
void sendTemp(float temp) {
  StaticJsonBuffer<300> JSONbuffer;
  JsonObject& JSONencoder = JSONbuffer.createObject();
  JSONencoder["tempH20"] = temp;
  char JSONmessageBuffer[50];
  JSONencoder.printTo(JSONmessageBuffer, sizeof(JSONmessageBuffer));
  Serial.println(JSONmessageBuffer);
  if (client.publish(tempH20Topic, JSONmessageBuffer) == true) {
      Serial.println("Success sending message");
  } else {
      Serial.println("Error sending message");
  }
  client.publish(logTopic, "Allarme Blocco ,resettato!");
}
void loop() {
  //ArduinoOTA.handle();
  if (!client.connected()) {
    reconnect();
  }
  float temperature = getTemperature();
  //sendTemp(temperature);
  dtostrf(temperature, 2, 2, temperatureString);
  // send temperature to the serial console
  Serial.println(temperatureString);
  smartDelay(20000);
  //client.loop();

}
void smartDelay(unsigned long ms)
{
  unsigned long start = millis();
  do
  {
    client.loop();
    delay(1);
  } while (millis() - start < ms);
}
